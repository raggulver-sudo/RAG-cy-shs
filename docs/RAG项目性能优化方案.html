<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG项目性能优化方案</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        h2 {
            color: #34495e;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            font-size: 1.8em;
        }

        h3 {
            color: #2980b9;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        h4 {
            color: #16a085;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .priority-high {
            background-color: #ffebee;
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .priority-medium {
            background-color: #fff3e0;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .priority-low {
            background-color: #e8f5e9;
            border-left: 4px solid #27ae60;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .problem-box {
            background-color: #fce4ec;
            border: 1px solid #e91e63;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .solution-box {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .code-block {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .toc {
            background-color: #ecf0f1;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .toc h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .toc ul {
            list-style-type: none;
            margin-left: 0;
        }

        .toc li {
            margin-bottom: 10px;
        }

        .toc a {
            color: #2980b9;
            text-decoration: none;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        .metric {
            display: inline-block;
            background-color: #95a5a6;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9em;
            margin-right: 10px;
        }

        .metric-high {
            background-color: #e74c3c;
        }

        .metric-medium {
            background-color: #f39c12;
        }

        .metric-low {
            background-color: #27ae60;
        }

        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .info {
            background-color: #d1ecf1;
            border: 1px solid #17a2b8;
            color: #0c5460;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RAG项目性能优化方案</h1>
        <p style="text-align: center; color: #7f8c8d; margin-bottom: 30px;">企业知识库系统性能分析与优化建议</p>

        <div class="toc">
            <h3>目录</h3>
            <ul>
                <li><a href="#section-1">1. 项目概述</a></li>
                <li><a href="#section-2">2. 性能瓶颈分析</a></li>
                <li><a href="#section-3">3. 详细优化方案</a></li>
                <li><a href="#section-4">4. 优化优先级建议</a></li>
                <li><a href="#section-5">5. 实施建议</a></li>
            </ul>
        </div>

        <h2 id="section-1">1. 项目概述</h2>
        <p>本项目是一个基于RAG（检索增强生成）技术的企业知识库系统，主要用于处理和查询PDF格式的财务报告和行业研究报告。系统通过向量检索、BM25检索和LLM重排序等技术，为用户提供精准的文档检索和问答服务。</p>

        <div class="table-container">
            <table>
                <tr>
                    <th>技术组件</th>
                    <th>技术栈</th>
                    <th>主要功能</th>
                </tr>
                <tr>
                    <td>向量检索</td>
                    <td>FAISS</td>
                    <td>基于语义相似度的文档检索</td>
                </tr>
                <tr>
                    <td>传统检索</td>
                    <td>BM25</td>
                    <td>基于关键词匹配的文档检索</td>
                </tr>
                <tr>
                    <td>重排序</td>
                    <td>LLM (DashScope)</td>
                    <td>对检索结果进行精准重排</td>
                </tr>
                <tr>
                    <td>Web界面</td>
                    <td>Streamlit</td>
                    <td>用户交互界面</td>
                </tr>
                <tr>
                    <td>PDF处理</td>
                    <td>PyMuPDF, MinerU</td>
                    <td>PDF解析和可视化</td>
                </tr>
            </table>
        </div>

        <div class="warning">
            <strong>当前问题：</strong>Web界面启动速度慢，用户查询响应时间过长，严重影响用户体验。
        </div>

        <h2 id="section-2">2. 性能瓶颈分析</h2>

        <h3>2.1 LLM重排序过程（最严重的瓶颈）</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>在 <code>reranking.py</code> 中使用 <code>ThreadPoolExecutor(max_workers=1)</code>，导致所有LLM调用串行执行</li>
                <li>每个文档都需要单独调用LLM API，28个文档需要28次API调用</li>
                <li>每次API调用都有网络延迟（通常500ms-2s），累积后非常耗时</li>
                <li>默认配置下，单次查询的LLM重排序可能需要14-56秒</li>
            </ul>
        </div>

        <div class="code-block">
<pre>with ThreadPoolExecutor(max_workers=1) as executor:
    all_results = list(executor.map(process_single_doc, documents))</pre>
        </div>

        <h3>2.2 向量检索过程</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>首次向量检索返回28个候选文档（<code>llm_reranking_sample_size=28</code>）</li>
                <li>FAISS索引使用 <code>IndexFlatL2</code>，在大规模数据下检索效率较低</li>
                <li>每次查询都需要加载向量索引，没有预加载机制</li>
                <li>向量检索时间随文档数量线性增长</li>
            </ul>
        </div>

        <h3>2.3 API调用优化</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>每次查询都需要调用LLM API生成答案</li>
                <li>没有缓存机制，相同问题重复调用API</li>
                <li>API调用可能存在网络延迟和QPS限制</li>
                <li>同步调用方式阻塞了后续处理</li>
            </ul>
        </div>

        <h3>2.4 PDF处理和Bbox计算</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>每次查询都需要读取PDF文件</li>
                <li>Bbox计算和匹配算法复杂，涉及多次循环和计算</li>
                <li>PDF页面渲染为图片需要时间（每页约100-500ms）</li>
                <li>没有缓存机制，重复渲染相同页面</li>
            </ul>
        </div>

        <h3>2.5 Web界面启动优化</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>Streamlit应用启动时需要加载所有依赖</li>
                <li>需要在启动时初始化多个组件（向量索引、BM25索引等）</li>
                <li>没有明显的启动优化代码</li>
                <li>首次查询时需要加载大量资源</li>
            </ul>
        </div>

        <h3>2.6 混合检索优化</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>同时进行向量检索和BM25检索，但串行执行</li>
                <li>需要合并和重排两种检索结果</li>
                <li>BM25检索可能没有优化，每次都需要重新计算</li>
                <li>权重配置可能不够优化</li>
            </ul>
        </div>

        <h3>2.7 文件I/O优化</h3>
        <div class="problem-box">
            <h4>问题描述：</h4>
            <ul>
                <li>每次查询都需要读取多个文件（PDF、向量索引、配置等）</li>
                <li>没有文件缓存机制</li>
                <li>可能存在重复的文件读取</li>
                <li>文件读取操作同步执行，阻塞后续处理</li>
            </ul>
        </div>

        <h2 id="section-3">3. 详细优化方案</h2>

        <h3>3.1 LLM重排序优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>批量重排序</strong>：将多个文档合并为一次LLM调用，让LLM一次性对所有文档评分
                    <div class="code-block">
<pre>def batch_rerank_documents(self, query: str, documents: List[Dict], batch_size: int = 10):
    """批量重排序文档"""
    all_scores = []
    for i in range(0, len(documents), batch_size):
        batch = documents[i:i + batch_size]
        prompt = self._create_batch_rerank_prompt(query, batch)
        scores = self._call_llm_batch(prompt)
        all_scores.extend(scores)
    return self._combine_scores(documents, all_scores)</pre>
                    </div>
                </li>
                <li><strong>增加并发度</strong>：如果API的QPS限制允许，可以增加 <code>max_workers</code> 的值
                    <div class="code-block">
<pre>with ThreadPoolExecutor(max_workers=3) as executor:
    all_results = list(executor.map(process_single_doc, documents))</pre>
                    </div>
                </li>
                <li><strong>缓存机制</strong>：对相同query的reranking结果进行缓存
                    <div class="code-block">
<pre>from functools import lru_cache

@lru_cache(maxsize=100)
def _get_cached_reranking(self, query_hash: str, doc_ids: tuple):
    """缓存重排序结果"""
    return self._perform_reranking(query_hash, doc_ids)</pre>
                    </div>
                </li>
                <li><strong>减少重排序样本量</strong>：将 <code>llm_reranking_sample_size</code> 从28降低到15-20</li>
                <li><strong>使用更快的模型</strong>：考虑使用更轻量级的模型进行reranking</li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>批量处理可减少API调用次数70-80%</li>
                <li>增加并发度可提升处理速度2-3倍</li>
                <li>缓存机制可减少重复查询时间90%以上</li>
                <li>总体可提升重排序速度5-10倍</li>
            </ul>
        </div>

        <h3>3.2 向量检索优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>优化FAISS索引</strong>：使用 <code>IndexIVFFlat</code> 或 <code>IndexIVFPQ</code> 替代 <code>IndexFlatL2</code>
                    <div class="code-block">
<pre>import faiss

# 使用IVF索引
quantizer = faiss.IndexFlatL2(dimension)
index = faiss.IndexIVFFlat(quantizer, dimension, nlist)
index.train(vectors)
index.add(vectors)</pre>
                    </div>
                </li>
                <li><strong>索引预加载</strong>：在Web启动时预先加载所有公司的FAISS索引
                    <div class="code-block">
<pre>@st.cache_resource
def load_all_vector_indexes():
    """预加载所有向量索引"""
    indexes = {}
    for company_name in company_names:
        indexes[company_name] = load_vector_index(company_name)
    return indexes</pre>
                    </div>
                </li>
                <li><strong>减少初始检索数量</strong>：将 <code>llm_reranking_sample_size</code> 降低到15-20</li>
                <li><strong>使用GPU加速</strong>：如果可用，使用GPU加速FAISS检索
                    <div class="code-block">
<pre>res = faiss.StandardGpuResources()
gpu_index = faiss.index_cpu_to_gpu(res, 0, index)</pre>
                    </div>
                </li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>IVF索引可提升检索速度3-5倍</li>
                <li>预加载可减少首次查询延迟50-70%</li>
                <li>GPU加速可进一步提升速度2-3倍</li>
                <li>总体可提升检索速度5-10倍</li>
            </ul>
        </div>

        <h3>3.3 API调用优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>实现查询缓存</strong>：使用Redis或内存缓存存储query-answer对
                    <div class="code-block">
<pre>import hashlib

def get_cache_key(query: str, company_name: str) -> str:
    """生成缓存键"""
    content = f"{query}_{company_name}"
    return hashlib.md5(content.encode()).hexdigest()

@st.cache_data(ttl=3600)
def cached_query(query: str, company_name: str):
    """缓存查询结果"""
    return perform_query(query, company_name)</pre>
                    </div>
                </li>
                <li><strong>异步API调用</strong>：使用异步IO进行API调用，提高并发性能
                    <div class="code-block">
<pre>import asyncio
import aiohttp

async def async_llm_call(prompt: str):
    """异步LLM调用"""
    async with aiohttp.ClientSession() as session:
        async with session.post(api_url, json={"prompt": prompt}) as response:
            return await response.json()</pre>
                    </div>
                </li>
                <li><strong>连接池</strong>：使用HTTP连接池减少连接建立开销
                    <div class="code-block">
<pre>import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
retry = Retry(total=3, backoff_factor=1)
adapter = HTTPAdapter(max_retries=retry, pool_connections=10, pool_maxsize=10)
session.mount('http://', adapter)
session.mount('https://', adapter)</pre>
                    </div>
                </li>
                <li><strong>批量处理</strong>：如果可能，将多个query合并为一次API调用</li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>缓存可减少重复查询时间90%以上</li>
                <li>异步调用可提升并发性能2-3倍</li>
                <li>连接池可减少连接建立时间30-50%</li>
                <li>总体可提升API调用效率3-5倍</li>
            </ul>
        </div>

        <h3>3.4 PDF处理和Bbox计算优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>PDF页面缓存</strong>：将PDF页面渲染为图片并缓存，避免重复渲染
                    <div class="code-block">
<pre>@st.cache_data(ttl=86400)
def render_pdf_page(pdf_path: str, page_num: int):
    """缓存PDF页面渲染"""
    doc = fitz.open(pdf_path)
    page = doc[page_num]
    pix = page.get_pixmap()
    img_data = pix.tobytes("png")
    doc.close()
    return img_data</pre>
                    </div>
                </li>
                <li><strong>优化bbox匹配算法</strong>：使用更高效的算法或数据结构
                    <div class="code-block">
<pre>from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

def fast_bbox_matching(query_embedding, bbox_embeddings, top_k=5):
    """使用向量相似度加速bbox匹配"""
    similarities = cosine_similarity(
        [query_embedding],
        bbox_embeddings
    )[0]
    top_indices = np.argsort(similarities)[-top_k:][::-1]
    return top_indices</pre>
                    </div>
                </li>
                <li><strong>延迟加载</strong>：只在需要显示时才加载和渲染PDF页面</li>
                <li><strong>预计算bbox信息</strong>：在ingestion阶段预计算并存储bbox相关信息</li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>PDF页面缓存可减少重复渲染时间95%以上</li>
                <li>优化算法可提升bbox匹配速度2-5倍</li>
                <li>延迟加载可减少初始加载时间50-70%</li>
                <li>总体可提升PDF处理效率5-10倍</li>
            </ul>
        </div>

        <h3>3.5 Web界面启动优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>懒加载</strong>：延迟加载非关键组件
                    <div class="code-block">
<pre>@st.cache_resource
def get_retriever():
    """延迟加载检索器"""
    return HybridRetriever()

# 在需要时才调用
if st.button("查询"):
    retriever = get_retriever()
    results = retriever.retrieve(...)</pre>
                    </div>
                </li>
                <li><strong>缓存初始化</strong>：缓存初始化结果，避免重复计算
                    <div class="code-block">
<pre>@st.cache_resource
def initialize_system():
    """缓存系统初始化"""
    vector_indexes = load_all_vector_indexes()
    bm25_index = load_bm25_index()
    return {
        'vector_indexes': vector_indexes,
        'bm25_index': bm25_index
    }</pre>
                    </div>
                </li>
                <li><strong>减少依赖</strong>：检查并移除不必要的依赖</li>
                <li><strong>使用缓存装饰器</strong>：对计算密集型函数使用 <code>@st.cache_data</code></li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>懒加载可减少启动时间30-50%</li>
                <li>缓存初始化可减少重复初始化时间80%以上</li>
                <li>减少依赖可加快启动速度10-20%</li>
                <li>总体可提升启动速度2-3倍</li>
            </ul>
        </div>

        <h3>3.6 混合检索优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>BM25索引缓存</strong>：预加载并缓存BM25索引
                    <div class="code-block">
<pre>@st.cache_resource
def load_bm25_index(company_name: str):
    """缓存BM25索引"""
    return BM25Retriever(company_name)</pre>
                    </div>
                </li>
                <li><strong>并行检索</strong>：同时进行向量检索和BM25检索
                    <div class="code-block">
<pre>from concurrent.futures import ThreadPoolExecutor

def parallel_retrieve(query: str, company_name: str):
    """并行检索"""
    with ThreadPoolExecutor(max_workers=2) as executor:
        future_vector = executor.submit(
            vector_retriever.retrieve, query, company_name
        )
        future_bm25 = executor.submit(
            bm25_retriever.retrieve, query, company_name
        )
        vector_results = future_vector.result()
        bm25_results = future_bm25.result()
    return merge_results(vector_results, bm25_results)</pre>
                    </div>
                </li>
                <li><strong>优化权重配置</strong>：调整 <code>llm_weight</code> 和其他权重参数</li>
                <li><strong>选择性使用BM25</strong>：根据query类型决定是否使用BM25</li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>BM25索引缓存可减少加载时间80%以上</li>
                <li>并行检索可提升检索速度1.5-2倍</li>
                <li>优化权重可提升检索准确率10-20%</li>
                <li>总体可提升混合检索效率2-3倍</li>
            </ul>
        </div>

        <h3>3.7 文件I/O优化</h3>
        <div class="solution-box">
            <h4>优化方案：</h4>
            <ol>
                <li><strong>内存缓存</strong>：将频繁访问的文件内容缓存在内存中
                    <div class="code-block">
<pre>from functools import lru_cache

@lru_cache(maxsize=100)
def read_file_cached(file_path: str):
    """缓存文件读取"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return f.read()</pre>
                    </div>
                </li>
                <li><strong>预加载</strong>：在应用启动时预加载关键文件
                    <div class="code-block">
<pre>@st.cache_resource
def preload_key_files():
    """预加载关键文件"""
    files = {}
    for file_path in key_file_paths:
        files[file_path] = read_file_cached(file_path)
    return files</pre>
                    </div>
                </li>
                <li><strong>使用更快的存储</strong>：如果可能，使用SSD存储</li>
                <li><strong>批量读取</strong>：合并多个小文件的读取操作</li>
            </ol>
            <h4>预期效果：</h4>
            <ul>
                <li>内存缓存可减少重复读取时间90%以上</li>
                <li>预加载可减少首次访问延迟50-70%</li>
                <li>SSD存储可提升读取速度2-5倍</li>
                <li>总体可提升文件I/O效率3-5倍</li>
            </ul>
        </div>

        <h2 id="section-4">4. 优化优先级建议</h2>

        <div class="priority-high">
            <h3>高优先级（立即实施）</h3>
            <p><span class="metric metric-high">影响程度</span> <span class="metric metric-high">实施难度</span></p>
            <ol>
                <li><strong>优化LLM重排序过程</strong> - 批量处理、增加并发、实现缓存
                    <ul>
                        <li>预期提升：5-10倍速度提升</li>
                        <li>实施时间：1-2周</li>
                        <li>技术难度：中等</li>
                    </ul>
                </li>
                <li><strong>实现查询缓存机制</strong> - 使用Redis或内存缓存
                    <ul>
                        <li>预期提升：重复查询90%以上时间减少</li>
                        <li>实施时间：3-5天</li>
                        <li>技术难度：低</li>
                    </ul>
                </li>
                <li><strong>减少初始检索样本量</strong> - 将llm_reranking_sample_size降低到15-20
                    <ul>
                        <li>预期提升：30-40%速度提升</li>
                        <li>实施时间：1天</li>
                        <li>技术难度：极低</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="priority-medium">
            <h3>中优先级（短期实施）</h3>
            <p><span class="metric metric-medium">影响程度</span> <span class="metric metric-medium">实施难度</span></p>
            <ol>
                <li><strong>优化FAISS索引和预加载</strong> - 使用IVF索引、预加载索引
                    <ul>
                        <li>预期提升：5-10倍速度提升</li>
                        <li>实施时间：1-2周</li>
                        <li>技术难度：中等</li>
                    </ul>
                </li>
                <li><strong>PDF页面缓存</strong> - 缓存渲染后的PDF页面
                    <ul>
                        <li>预期提升：重复访问95%以上时间减少</li>
                        <li>实施时间：3-5天</li>
                        <li>技术难度：低</li>
                    </ul>
                </li>
                <li><strong>异步API调用</strong> - 使用异步IO进行API调用
                    <ul>
                        <li>预期提升：2-3倍并发性能提升</li>
                        <li>实施时间：1-2周</li>
                        <li>技术难度：中等</li>
                    </ul>
                </li>
                <li><strong>Web界面启动优化</strong> - 懒加载、缓存初始化
                    <ul>
                        <li>预期提升：2-3倍启动速度提升</li>
                        <li>实施时间：3-5天</li>
                        <li>技术难度：低</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="priority-low">
            <h3>低优先级（长期优化）</h3>
            <p><span class="metric metric-low">影响程度</span> <span class="metric metric-low">实施难度</span></p>
            <ol>
                <li><strong>优化bbox匹配算法</strong> - 使用更高效的算法
                    <ul>
                        <li>预期提升：2-5倍速度提升</li>
                        <li>实施时间：2-3周</li>
                        <li>技术难度：高</li>
                    </ul>
                </li>
                <li><strong>使用GPU加速</strong> - GPU加速FAISS检索
                    <ul>
                        <li>预期提升：2-3倍速度提升</li>
                        <li>实施时间：1-2周</li>
                        <li>技术难度：中等</li>
                    </ul>
                </li>
                <li><strong>混合检索并行化</strong> - 并行执行向量检索和BM25检索
                    <ul>
                        <li>预期提升：1.5-2倍速度提升</li>
                        <li>实施时间：3-5天</li>
                        <li>技术难度：低</li>
                    </ul>
                </li>
                <li><strong>文件I/O优化</strong> - 内存缓存、预加载
                    <ul>
                        <li>预期提升：3-5倍速度提升</li>
                        <li>实施时间：1周</li>
                        <li>技术难度：低</li>
                    </ul>
                </li>
            </ol>
        </div>

        <h2 id="section-5">5. 实施建议</h2>

        <h3>5.1 实施策略</h3>
        <div class="info">
            <h4>分阶段实施：</h4>
            <ol>
                <li><strong>第一阶段（1-2周）</strong>：实施高优先级优化
                    <ul>
                        <li>优化LLM重排序过程</li>
                        <li>实现查询缓存机制</li>
                        <li>减少初始检索样本量</li>
                    </ul>
                </li>
                <li><strong>第二阶段（2-3周）</strong>：实施中优先级优化
                    <ul>
                        <li>优化FAISS索引和预加载</li>
                        <li>PDF页面缓存</li>
                        <li>Web界面启动优化</li>
                    </ul>
                </li>
                <li><strong>第三阶段（3-4周）</strong>：实施低优先级优化
                    <ul>
                        <li>优化bbox匹配算法</li>
                        <li>使用GPU加速</li>
                        <li>混合检索并行化</li>
                    </ul>
                </li>
            </ol>
        </div>

        <h3>5.2 性能监控</h3>
        <div class="info">
            <h4>建立性能监控机制：</h4>
            <ul>
                <li>记录每个查询的响应时间</li>
                <li>监控各个组件的耗时分布</li>
                <li>跟踪缓存命中率</li>
                <li>记录API调用次数和延迟</li>
                <li>定期进行性能测试和优化</li>
            </ul>
        </div>

        <h3>5.3 测试建议</h3>
        <div class="info">
            <h4>性能测试方法：</h4>
            <ul>
                <li>使用相同的测试数据集进行前后对比</li>
                <li>测试不同查询类型的性能表现</li>
                <li>模拟并发用户场景</li>
                <li>测试缓存效果</li>
                <li>记录优化前后的性能指标</li>
            </ul>
        </div>

        <h3>5.4 注意事项</h3>
        <div class="warning">
            <h4>实施过程中的注意事项：</h4>
            <ul>
                <li>每次只实施一个优化，避免同时修改多个功能</li>
                <li>在实施前备份代码和数据</li>
                <li>在测试环境充分测试后再部署到生产环境</li>
                <li>注意API的QPS限制，避免超限</li>
                <li>监控优化效果，及时调整策略</li>
                <li>保持代码的可维护性和可读性</li>
            </ul>
        </div>

        <h3>5.5 预期总体效果</h3>
        <div class="table-container">
            <table>
                <tr>
                    <th>性能指标</th>
                    <th>优化前</th>
                    <th>优化后（预期）</th>
                    <th>提升幅度</th>
                </tr>
                <tr>
                    <td>Web界面启动时间</td>
                    <td>10-20秒</td>
                    <td>3-5秒</td>
                    <td>3-4倍</td>
                </tr>
                <tr>
                    <td>首次查询响应时间</td>
                    <td>30-60秒</td>
                    <td>5-10秒</td>
                    <td>5-6倍</td>
                </tr>
                <tr>
                    <td>重复查询响应时间</td>
                    <td>30-60秒</td>
                    <td>1-2秒</td>
                    <td>30-60倍</td>
                </tr>
                <tr>
                    <td>PDF页面显示时间</td>
                    <td>2-5秒</td>
                    <td>0.5-1秒</td>
                    <td>4-5倍</td>
                </tr>
                <tr>
                    <td>并发查询处理能力</td>
                    <td>1-2 QPS</td>
                    <td>5-10 QPS</td>
                    <td>5倍</td>
                </tr>
            </table>
        </div>

        <div class="footer">
            <p>文档生成时间：2026-01-04</p>
            <p>版本：1.0</p>
            <p>如有疑问或建议，请联系技术团队</p>
        </div>
    </div>
</body>
</html>